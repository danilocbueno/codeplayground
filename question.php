<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * codeplayground question definition class.
 *
 * @package    qtype
 * @subpackage codeplayground
 * @copyright  THEYEAR YOURNAME (YOURCONTACTINFO)

 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */


defined('MOODLE_INTERNAL') || die();


/**
 * Represents a codeplayground question.
 *
 * @copyright  THEYEAR YOURNAME (YOURCONTACTINFO)

 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */


class qtype_codeplayground_question extends question_graded_automatically {


    public function get_expected_data() {
        $resposta =array('answer' => PARAM_RAW_TRIMMED,
            'answerCSS' => PARAM_RAW_TRIMMED,
            'answerJS' => PARAM_RAW_TRIMMED);
        return $resposta;
    }


    public function summarise_response(array $response) {
        // TODO.
        return null;
    }

    public function is_complete_response(array $response) {
        // TODO.
        return true;
    }

    public function get_validation_error(array $response) {
        // TODO.
        return '';
    }

    public function is_same_response(array $prevresponse, array $newresponse) {
        // TODO.
        return question_utils::arrays_same_at_key_missing_is_blank(
                $prevresponse, $newresponse, 'answer');
    }


    public function get_correct_response() {
        // TODO.
        return array();
    }


    public function check_file_access($qa, $options, $component, $filearea,
            $args, $forcedownload) {
        // TODO.
        if ($component == 'question' && $filearea == 'hint') {
            return $this->check_hint_file_access($qa, $options, $args);

        } else {
            return parent::check_file_access($qa, $options, $component, $filearea,
                    $args, $forcedownload);
        }
    }

    /**
     * When an in-progress {@link question_attempt} is re-loaded from the database, this method is called so that the
     * question can re-initialise its internal state as needed by this attempt. For example, the multiple choice
     * question type needs to set the order of the choices to the order that was set up when start_attempt was called
     * originally. All the information required to do this should be in the $step object, which is the first step of the
     * question_attempt being loaded.
     *
     * @param question_attempt_step The first step of the {@link question_attempt} being loaded.
     */
    public function apply_attempt_state ( question_attempt_step $step ) {
        global $DB;

        $stepid = $step->get_id ();

        // We need a place to store the feedback generated by JUnit.
        // Therefore we want to know the questionattemptid.
        if ( !empty ( $stepid ) ) {
            $record = $DB->get_record ( 'question_attempt_steps', array (
                'id' => $stepid
            ), 'questionattemptid' );
            if ( $record ) {
                $this->questionattemptid = $record->questionattemptid;
            }
        }
    }

    private function verify_html($html_code) {
        $data = array("code" => $html_code);

        $config['url'] = 'https://validator.w3.org/nu/?out=json&lang=pt-BR';
        $config['useragent'] = 'Mozilla/5.0 (Windows NT 6.2; WOW64; rv:17.0) Gecko/20100101 Firefox/17.0';

        $ch = curl_init ();
        curl_setopt( $ch, CURLOPT_URL, $config['url']);
        curl_setopt( $ch, CURLOPT_HTTPHEADER, array('Content-Type: text/html; charset=utf-8'));
        curl_setopt( $ch, CURLOPT_VERBOSE, 0 );
        curl_setopt( $ch, CURLOPT_USERAGENT, $config['useragent']);
        curl_setopt( $ch, CURLOPT_POSTFIELDS, utf8_encode($html_code));
        curl_setopt( $ch, CURLOPT_FOLLOWLOCATION, 1 );
        curl_setopt( $ch, CURLOPT_RETURNTRANSFER, 1 );
        curl_setopt( $ch, CURLOPT_AUTOREFERER, 1 );
        curl_setopt( $ch, CURLOPT_MAXREDIRS, 10 );
        curl_setopt( $ch, CURLOPT_CONNECTTIMEOUT, 5 );
        $result = curl_exec ( $ch );


        $HTTPStatusCode = curl_getinfo ( $ch, CURLINFO_HTTP_CODE );
        curl_close ( $ch );

        if ( $HTTPStatusCode != 200 ) {

            return array (
                'error' => true,
                'errortype' => 'REMOTE_SERVER_ERROR',
                'message' => $result
            );
        }

        $json = json_decode ( $result, true );
        if ( $json === null ) {
            return array (
                'error' => true,
                'errortype' => 'REMOTE_SERVER_ERROR',
                'message' => 'JSON decoding error'
            );
        }
        return $json;
    }

    private function save_feedback($feedback) {
        global $DB;

        $cur_feedback = $DB->get_record ( 'qtype_codeplay_feedback', array (
            'questionattemptid' => $this->questionattemptid
        ));

        $db_feedback = new stdClass();
        $db_feedback->questionattemptid = $this->questionattemptid;
        $db_feedback->feedback = $feedback;
        if ( $cur_feedback ) {
            $db_feedback->id = $cur_feedback->id;
            $DB->update_record ( 'qtype_codeplay_feedback', $db_feedback );
        } else {
            $DB->insert_record ( 'qtype_codeplay_feedback', $db_feedback );
        }
    }

    private function deal_with_api_response($data) {
        $messageFeedback = '<h3>HTML</h3>';
        $totalErrors = 0;

        if(empty($data["messages"])) {
            $messageFeedback = get_string('document_ok');
        } else {
            $totalErrors = sizeof($data["messages"]);
            foreach($data["messages"] as $node) {
                $messageFeedback .= '<p>' . $node["message"] . '</p>';
                //veja aqui: https://github.com/danilocbueno/danilocbueno.github.io/commit/bb2cd468f8a1e983d57a5a74c69e9b23e6a7e476
            }
        }

        return array("errors"=> $totalErrors, "feedback" => $messageFeedback);
    }


    private function verify_css($css_code) {
        $config['useragent'] = 'Mozilla/5.0 (Windows NT 6.2; WOW64; rv:17.0) Gecko/20100101 Firefox/17.0';
        $endpoint = 'https://jigsaw.w3.org/css-validator/validator';
        $params = array("text" => $css_code, "output" => "json");
        $url = $endpoint . '?' . http_build_query($params);

        $ch = curl_init ();
        curl_setopt( $ch, CURLOPT_URL, $url);
        curl_setopt( $ch, CURLOPT_HTTPHEADER, array('Content-Type: text/html; charset=utf-8'));
        curl_setopt( $ch, CURLOPT_VERBOSE, 0 );
        curl_setopt( $ch, CURLOPT_USERAGENT, $config['useragent']);
        curl_setopt( $ch, CURLOPT_FOLLOWLOCATION, 1 );
        curl_setopt( $ch, CURLOPT_RETURNTRANSFER, 1 );
        curl_setopt( $ch, CURLOPT_AUTOREFERER, 1 );
        curl_setopt( $ch, CURLOPT_MAXREDIRS, 10 );
        curl_setopt( $ch, CURLOPT_CONNECTTIMEOUT, 5 );
        $result = curl_exec ( $ch );


        $HTTPStatusCode = curl_getinfo ( $ch, CURLINFO_HTTP_CODE );
        curl_close ( $ch );

        if ( $HTTPStatusCode != 200 ) {

            return array (
                'error' => true,
                'errortype' => 'REMOTE_SERVER_ERROR',
                'message' => $result
            );
        }

        $json = json_decode ( $result, true );
        if ( $json === null ) {
            return array (
                'error' => true,
                'errortype' => 'REMOTE_SERVER_ERROR',
                'message' => 'JSON decoding error'
            );
        }

        return $json;
    }

    private function deal_with_css_results($json_CSS) {
        $cssResults = $json_CSS['cssvalidation'];
        $messageFeedback = '<h3>CSS</h3>';
        $totalErrors = 0;

        if(!isset($cssResults["errors"]) ){
            $messageFeedback .= get_string('document_ok');
        } else {
            $totalErrors = sizeof($cssResults["errors"]);
            foreach($cssResults["errors"] as $error) {
                $messageFeedback .= '<p>' . $error["message"] . '</p>';
            }
        }

        return array("errors"=> $totalErrors, "feedback" => $messageFeedback);
    }

    public function grade_response(array $response) {

        //check if exist answer
        if(empty($response) || empty(trim($response['answer']))) {
            $this->save_feedback('Vazio');
            return array(0, question_state::graded_state_for_fraction(0));
        }

        $html_code = $response['answer'];
        $css_code = $response['answerCSS'];
        $js_code = $response['answerJS'];

        $html_results = $this->verify_html($html_code);
        $html_results = $this->deal_with_api_response($html_results);

        if(!empty($response['answerCSS'])) {
            $css_results = $this->verify_css($css_code);
            $css_results = $this->deal_with_css_results($css_results);
        } else {
            $css_results["errors"] = 0;
            $css_results["feedback"] = '';
        }

        $fraction = ($html_results["errors"] + $css_results["errors"])/100;
        $total_score = 1 - $fraction;

        $feedback = $html_results["feedback"] . $css_results["feedback"] . '<p>' . get_string('total_failures') . $fraction*100 .  '</p>';

        $this->save_feedback($feedback);
        return array($total_score, question_state::graded_state_for_fraction($total_score));
    }

    public function compute_final_grade($responses, $totaltries) {
        // TODO.
        return 0;
    }
}
